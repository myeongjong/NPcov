max_iter    <- 100
wave_model  <- function(h, c_0, c_1, a) ifelse(h == 0, 0, c_0 + c_1 * (1-a*sin(h/a)/h))
x           <- seq(0.1, 10, by = 0.1)
y           <- wave_model(x, 0,1,1)
y           <- 1-y
y_err       <- y + rnorm(length(y), 0, 0.2)
r           <- seq(0.05, 10, by = 0.05)
ptm         <- proc.time()
storage     <- IDEA(x, y_err, h, n, m, tau, kernel, "general", method, dist_init, min_iter, max_iter)
ptm         <- proc.time() - ptm
data        <- na.omit( unlist(storage[[2]]) %>% )
data        <- na.omit( unlist(storage[[2]]) )
z           <- rep(NA, length(r))
for(i in 1:length(r)) z[i] <- ksreflect(r = r[i], data = data, h = h, kernel = kernel, shape = shape)
shape       <- "general"
z           <- rep(NA, length(r))
for(i in 1:length(r)) z[i] <- ksreflect(r = r[i], data = data, h = h, kernel = kernel, shape = shape)
plot(x, y_err, col = "gray")
lines(r, z, col = "red", lwd = 2)
lines(x, y, col = "black", lwd = 2)
plot(na.omit(storage$history_obj_min), type="l", ylim = c(4, 15))
lines(na.omit(storage$history_obj_max_sel))
lines(na.omit(storage$history_obj_mean))
lines(na.omit(storage$history_obj_max))
ptm
plot(na.omit(storage$history_obj_min), type="l", ylim = c(4, 15), lty = "dotted")
lines(na.omit(storage$history_obj_max_sel), lty = "dotted")
lines(na.omit(storage$history_obj_max_sel), col = "red")
lines(na.omit(storage$history_obj_mean), col = "blue")
lines(na.omit(storage$history_obj_max), lty = "dotted")
plot(na.omit(storage$history_obj_min), type="l", ylim = c(4, 15), lty = "dotted", xlab = "Iteration", ylab = "Objective value")
lines(na.omit(storage$history_obj_max_sel), col = "red")
lines(na.omit(storage$history_obj_mean), col = "blue")
lines(na.omit(storage$history_obj_max), lty = "dotted")
ptm
m           <- 10
n           <- 100
tau         <- 0.2
h           <- 0.1
kernel      <- "gaussian"
shape       <- "general"
method      <- "reflection"
dist_init   <- "exponential"
min_iter    <- 20
max_iter    <- 100
wave_model  <- function(h, c_0, c_1, a) ifelse(h == 0, 0, c_0 + c_1 * (1-a*sin(h/a)/h))
x           <- seq(0.1, 10, by = 0.1)
y           <- wave_model(x, 0, 1, 1)
y           <- 1 - y
y_err       <- y + rnorm(length(y), 0, 0.2)
r           <- seq(0.05, 10, by = 0.05)
ptm         <- proc.time()
storage     <- IDEA(x, y_err, h, n, m, tau, kernel, shape, method, dist_init, min_iter, max_iter)
ptm         <- proc.time() - ptm
data        <- na.omit( unlist(storage[[2]]) )
z           <- rep(NA, length(r))
for(i in 1:length(r)) z[i] <- ksreflect(r = r[i], data = data, h = h, kernel = kernel, shape = shape)
plot(x, y_err, col = "gray")
lines(r, z, col = "red", lwd = 2)
lines(x, y, col = "black", lwd = 2)
plot(na.omit(storage$history_obj_min), type="l", ylim = c(4, 15), lty = "dotted", xlab = "Iteration", ylab = "Objective value")
lines(na.omit(storage$history_obj_max_sel), col = "red")
lines(na.omit(storage$history_obj_mean), col = "blue")
lines(na.omit(storage$history_obj_max), lty = "dotted")
ptm
storage$iteration
###########################################################################
###
###    Author : MYEONGJONG KANG
###    E-mail : kmj.stat@gmail.com
###
###    Description :
###
###    Reference : Cressie, N. (2015). Statistics for spatial data. John Wiley & Sons.
###
###########################################################################
###########################################################################
###    Some isotropic variogram models (p61)
###########################################################################
#' Linear isotropic semivariogram model
#'
#' @param h h
#' @param c c
#' @param b b
#'
#' @return Numeric value
#' @export
#'
#' @examples
ftn_linear <- function(h, c, b)
{
ifelse(h == 0, 0, c + b * h)
}
#' Spherical isotropic semivariogram model
#'
#' @param h h
#' @param c_0 c0
#' @param c_1 c1
#' @param a a
#'
#' @return Numeric value
#' @export
#'
#' @examples
ftn_spherical <- function(h, c_0, c_1, a)
{
ifelse(h == 0, 0, ifelse(h <= a, c_0 + c_1 * (1.5*(h/a) - 0.5*(h/a)^3), c_0 + c_1))
}
#' Exponential isotropic semivariogram model
#'
#' @param h h
#' @param c_0 c0
#' @param c_1 c1
#' @param a a
#'
#' @return Numeric value
#' @export
#'
#' @examples
ftn_exponential <- function(h, c_0, c_1, a)
{
ifelse(h == 0, 0, c_0 + c_1 * (1-exp(-h/a)))
}
#' Rational quadratic semivariogram model
#'
#' @param h h
#' @param c_0 c0
#' @param c_1 c1
#' @param a a
#'
#' @return Numeric value
#' @export
#'
#' @examples
ftn_rational_quadratic <- function(h, c_0, c_1, a)
{
ifelse(h == 0, 0, c_0 + c_1 * h^2 / (1 + (h^2)/a))
}
#' Wave isotropic semivariogram model
#'
#' @param h h
#' @param c_0 c0
#' @param c_1 c1
#' @param a a
#'
#' @return Numeric value
#' @export
#'
#' @examples
ftn_wave <- function(h, c_0, c_1, a)
{
ifelse(h == 0, 0, c_0 + c_1 * (1-a*sin(h/a)/h))
}
#' Power isotropic semivariogram model
#'
#' @param h h
#' @param c c
#' @param b b
#' @param lambda lambda
#'
#' @return Numeric value
#' @export
#'
#' @examples
ftn_power <- function(h, c, b, lambda)
{
ifelse(h == 0, 0, c + b * h^lambda)
}
x = seq(0, 15, by = 0.001)
y = ftn_linear(x, 0, 1)
plot(x, y, type="l")
y = ftn_spherical(x, 0, 1, 1)
plot(x, y, type="l")
y = ftn_exponential(x, 0, 1, 1)
plot(x, y, type="l")
y = ftn_rational_quadratic(x, 0, 1, 1)
plot(x, y, type="l")
y = ftn_wave(x, 0, 1, 1)
plot(x, y, type="l")
y = ftn_power(x, 0, 1, 1)
plot(x, y, type="l")
library(NPcov)
ls("package:NPcov")
library(NPcov)
library(NPcov)
library(NPcov)
library(NPcov)
library(NPcov)
library(NPcov)
?idea
library(NPcov)
?IDEA
m           <- 20
n           <- 100
tau         <- 0.2
h           <- 0.1
kernel      <- "gaussian"
shape       <- "general"
method      <- "reflection"
dist_init   <- "exponential"
min_iter    <- 20
max_iter    <- 100
wave_model  <- function(h, c_0, c_1, a) ifelse(h == 0, 0, c_0 + c_1 * (1-a*sin(h/a)/h))
x           <- seq(0.1, 10, by = 0.1)
y           <- wave_model(x, 0, 1, 1)
y           <- 1 - y
y_err       <- y + rnorm(length(y), 0, 0.2)
r           <- seq(0.05, 10, by = 0.05)
ptm         <- proc.time()
storage     <- IDEA(x, y_err, h, n, m, tau, kernel, shape, method, dist_init, min_iter, max_iter)
ptm         <- proc.time() - ptm
data        <- na.omit( unlist(storage[[2]]) )
z           <- rep(NA, length(r))
for(i in 1:length(r)) z[i] <- ksreflect(r = r[i], data = data, h = h, kernel = kernel, shape = shape)
plot(x, y_err, col = "gray")
lines(r, z, col = "red", lwd = 2)
lines(x, y, col = "black", lwd = 2)
plot(na.omit(storage$history_obj_min), type="l", ylim = c(4, 15), lty = "dotted", xlab = "Iteration", ylab = "Objective value")
lines(na.omit(storage$history_obj_max_sel), col = "red")
lines(na.omit(storage$history_obj_mean), col = "blue")
lines(na.omit(storage$history_obj_max), lty = "dotted")
ptm
storage$iteration
history_obj_min         <- rep(NA, max_iter)
history_obj_max         <- rep(NA, max_iter)
history_obj_max_sel     <- rep(NA, max_iter)
history_obj_mean        <- rep(NA, max_iter)
history_KL              <- rep(NA, max_iter)
storage                 <- .initialization(n, m, dist_init)
.initialization <- function(n, m, dist_init = "exponential")
{
if(dist_init == "exponential"){
storage     <- as.data.frame(matrix(rexp(n * m), m, n))
} else {
storage     <- as.data.frame(matrix(rexp(n * m), m, n))
} ; colnames(storage) <- paste0("Z", 1:n)
return( storage )
}
.selection <- function(storage, tau, objective)
{
storage     <- storage[,order(objective)]
objective   <- objective[order(objective)]
storage[,(as.integer(tau * ncol(storage)) + 1):ncol(storage)] <- NA
return( storage )
}
.replacement <- function(storage, tau, h, kernel = "epan", method = "reflection")
{
n           <- ncol(storage)
m           <- nrow(storage)
num_sample  <- as.integer(tau * n)
data        <- as.numeric(na.omit(unlist(storage)))
storage           <- cbind(storage[,1:num_sample], matrix(rkrnl((n - num_sample) * m, data, h, kernel, method), m, n-num_sample))
colnames(storage) <- paste0("Z", 1:n)
return( storage )
}
.termination <- function(storage_old, storage, h, kernel = "epan", method = "reflection") {
data_old <- na.omit(unlist(storage_old))
data_new <- na.omit(unlist(storage))
abs(sum( log( krnl(data_old, h, data_old, kernel, method) / krnl(data_new, h, data_old, kernel, method) ) )) / length(data_old)
}
history_obj_min         <- rep(NA, max_iter)
history_obj_max         <- rep(NA, max_iter)
history_obj_max_sel     <- rep(NA, max_iter)
history_obj_mean        <- rep(NA, max_iter)
history_KL              <- rep(NA, max_iter)
storage                 <- .initialization(n, m, dist_init)
obj_value               <- eval_sse(storage, x, y, h, kernel, shape)
history_obj_min[1]      <- min(obj_value)
history_obj_mean[1]     <- mean(obj_value)
history_obj_max[1]      <- max(obj_value)
storage                 <- .selection(storage, tau, obj_value)
history_obj_max_sel[1]  <- obj_value[order(obj_value)][(as.integer(tau * ncol(storage)))]
library(NPcov)
library(NPcov)
library(NPcov)
library(NPcov)
library(NPcov)
library(NPcov)
library(NPcov)
library(NPcov)
library(NPcov)
library(NPcov)
library(NPcov)
library(NPcov)
library(NPcov)
RandomFieldsUtils::struveH(0.5, 0.5)
NPcov:::StruveH(0.5, 0.5)
RandomFieldsUtils::struveH
library(NPcov)
C_StruveH
.struve <- function(x, nu) {
storage.mode(x) <- "double"
storage.mode(nu) <- "double"
.Call(C_StruveH, x, nu)
}
struveH <- function(x, nu)  .struve(x, nu)
struveH(0.5, 0.5)
.struve <- function(x, nu) {
storage.mode(x) <- "double"
storage.mode(nu) <- "double"
.Call(StruveH, x, nu)
}
struveH <- function(x, nu)  .struve(x, nu)
struveH(0.5, 0.5)
.struve <- function(x, nu) {
storage.mode(x) <- "double"
storage.mode(nu) <- "double"
.Call(NPcov:::StruveH, x, nu)
}
struveH <- function(x, nu)  .struve(x, nu)
struveH(0.5, 0.5)
library(NPcov)
.struve <- function(x, nu) {
storage.mode(x) <- "double"
storage.mode(nu) <- "double"
.Call(NPcov:::StruveH, x, nu)
}
struveH <- function(x, nu)  .struve(x, nu)
struveH(0.5, 0.5)
.struve <- function(x, nu) {
storage.mode(x) <- "double"
storage.mode(nu) <- "double"
NPcov:::StruveH(x, nu)
}
struveH <- function(x, nu)  .struve(x, nu)
struveH(0.5, 0.5)
struveH
library(NPcov)
.struve <- function(x, nu) {
storage.mode(x) <- "double"
storage.mode(nu) <- "double"
NPcov:::StruveH(x, nu)
}
struveHa <- function(x, nu)  .struve(x, nu)
struveHa(0.5, 0.5)
struveHa(0.5, 0.5)
x=0.5
nu = 0.5
storage.mode(x) <- "double"
storage.mode(nu) <- "double"
NPcov:::StruveH(x, nu)
NPcov:::StruveH(x, nu)
library(NPcov)
library(NPcov)
library(NPcov)
library(NPcov)
library(NPcov)
library(NPcov)
NPcov:::StruveH(0.5, 0.5)
NPcov::StruveH(0.5, 0.5)
StruveH(0.5, 0.5)
library(NPcov)
library(NPcov)
struve(0.5, 0.5)
NPcov:::struve(0.5, 0.5)
struve
NPcov:::struve
library(NPcov)
NPcov:::struve(0.5, 0.5)
library(NPcov)
NPcov:::struve(0.5, 0.5)
NPcov:::StruveH()
NPcov:::StruveH(0.5, 0.5)
NPcov:::StruveH(as.double(0.5), as.double(0.5))
temp <- NPcov:::StruveH(0.5, 0.5)
library(NPcov)
temp <- NPcov:::StruveH(0.5, 0.5)
temp <- NPcov:::struve(0.5, 0.5)
library(NPcov)
library(NPcov)
temp <- NPcov:::struve(0.5, 0.5)
NPcov:::StruveH(0.5, 0.5)
library(NPcov)
struve(0.5, 0.5)
RandomFieldsUtils::struveH(0.5, 0.5)
x = 0.2 ; nu = 0.3 ; struve(x, nu) ; RandomFieldsUtils::struveH(x, nu)
x = 0.2 ; nu = 0.1 ; struve(x, nu) ; RandomFieldsUtils::struveH(x, nu)
x = 0.8 ; nu = 0.1 ; struve(x, nu) ; RandomFieldsUtils::struveH(x, nu)
library(NPcov)
library(NPcov)
besselK
besselJ(0.5, 0.5)
stat::besselJ(0.5, 0.5)
stat:::besselJ(0.5, 0.5)
besselJ(0.5, 0.5)
0.5409738
library(NPcov)
library(NPcov)
install.packages("RcppNumerical")
install.packages("RcppEigen")
usethis::use_package("RcppNumerical")
?usethis::use_package
usethis::use_package("RcppEigen", "LinkingTo")
usethis::use_package("RcppNumerical", "LinkingTo")
library(NPcov)
NPcov:::integrate_test()
library(NPcov)
integrate_test()
library(NPcov)
integrate_test(0.5, 0.5, 0.5)
library(NPcov)
integrate_test(0.5, 0.5, 0.5)
library(NPcov)
NPcov:::.besselJ_generalized(0.5, 0.5, 0.5)
integrate_test(0.5, 0.5, 0.5)
library(NPcov)
NPcov:::.besselJ_generalized(0.5, 0.5, 0.5)
besselJ_generalized_C(0.5, 0.5, 0.5)
NPcov:::.besselJ_generalized(0.5, 0.5, 0.76)
besselJ_generalized_C(0.5, 0.5, 0.76)
library(NPcov)
NPcov:::.struveH_modified(0.5, 0.5)
NPcov:::.struveH_modified(-0.5, 0.5)
RandomFieldsUtils::struveH(-0.5, 0.5)
struveH_modified_C(0.5, 0.5)
struveH_modified_C(-0.5, 0.5)
besselJ_modified_C(0.5, 0.5)
besselJ_modified_C(-0.5, 0.5)
NPcov:::.besselJ_modified(0.5, 0.5)
NPcov:::.besselJ_modified(-0.5, 0.5)
NPcov:::.besselJ_generalized(0.5, 0.5, 0.5)
besselJ_generalized_C(0.5, 0.5, 0.5)
library(NPcov)
besselJ_modified_C(0.5, 0.5)
besselJ_generalized_C(0.5, 0.5, 0.5)
struveH_modified_C(0.5, 0.5)
NPcov:::.struveH_modified(0.5, 0.5)
library(NPcov)
library(NPcov)
lmda0_C(0.5)
NPcov:::.lmda0(0.5)
library(NPcov)
lmda1_C(0.5)
NPcov:::.lmda1(0.5)
NPcov:::.lmda1(0.7)
lmda1_C(0.7)
library(NPcov)
library(NPcov)
est_2d_epan_refl_C(0.5, 0.5, 0.5)
library(NPcov)
est_2d_epan_refl_C(0.5, c(0.5, 10), 0.5)
est_2d_epan_refl_C(0.5, c(0.5, 1), 0.5)
est_2d_epan_refl_C(0.5, c(0.5, 10), 0.5)
NPcov:::.est_2d_epan_refl(0.5, c(0.5, 10), 0.5)
NPcov:::.est_2d_epan_refl(0.5, c(0.5), 0.5)
NPcov:::.est_2d_epan_refl(0.5, c(0.5), 0.5) / 2
library(NPcov)
NPcov:::.est_2d_epan_refl(0.5, c(0.5, 2.5), 0.5)
est_2d_epan_refl_C(0.5, c(0.5, 2.5), 0.5)
est_2d_epan_refl_C(0.5, c(2.5), 0.5)
est_2d_epan_refl_C(0.5, c(0.5), 0.5)
NPcov:::.est_2d_epan_refl(0.5, c(0.5), 0.5)
library(NPcov)
est_2d_epan_refl_C(0.5, c(0.5, 2.5), 0.5)
NPcov:::.est_2d_epan_refl(0.5, c(0.5, 2.5), 0.5)
library(NPcov)
est_2d_epan_refl_C(0.5, c(0.5, 2.5), 0.5)
est_2d_gaussian_refl_C(0.5, c(0.5, 2.5), 0.5)
est_2d_uniform_refl_C(0.5, c(0.5, 2.5), 0.5)
NPcov:::.est_2d_epan_refl(0.5, c(0.5, 2.5), 0.5)
NPcov:::.est_2d_gaussian_refl(0.5, c(0.5, 2.5), 0.5)
NPcov:::.est_2d_uniform_refl(0.5, c(0.5, 2.5), 0.5)
usethis::use_package("RcppArmadillo")
usethis::use_package("RcppArmadillo", "LinkingTo")
library(NPcov)
est_infd_epan_refl_C(0.5, c(0.5, 2.5), 0.5)
library(NPcov)
est_infd_epan_refl_C(0.5, c(0.5, 2.5), 0.5)
library(NPcov)
est_infd_epan_refl_C(0.5, c(0.5, 1.5), 0.5)
NPcov:::.est_infd_epan_refl(0.5, c(0.5, 1.5), 0.5)
library(NPcov)
NPcov:::.est_infd_gaussian_refl(0.5, c(0.5, 1.5), 0.2)
est_infd_gaussian_refl_C(0.5, c(0.5, 1.5), 0.2)
library(NPcov)
NPcov:::.est_infd_uniform_refl(0.5, c(0.5, 1.5), 0.2)
est_infd_uniform_refl_C(0.5, c(0.5, 1.5), 0.2)
library(NPcov)
estimator_2d_reflection(0.5, c(0.5, 1.5), 0.1, "epan")
library(NPcov)
?ksreflect
r <- seq(0.05, 5, by = 0.05)
data <- rexp(10)
v1 <- c() ; v2 <- c() ; v3 <- c()
v4 <- c() ; v5 <- c() ; v6 <- c()
for(i in 1:length(r)) v1[i] <- ksreflect(r = r[i], data = data, h = 1, kernel = "epan", shape = "general")
for(i in 1:length(r)) v2[i] <- ksreflect(r = r[i], data = data, h = 1, kernel = "gaussian", shape = "general")
for(i in 1:length(r)) v3[i] <- ksreflect(r = r[i], data = data, h = 1, kernel = "uniform", shape = "general")
for(i in 1:length(r)) v4[i] <- ksreflect(r = r[i], data = data, h = 1, kernel = "epan", shape = "monotone")
for(i in 1:length(r)) v5[i] <- ksreflect(r = r[i], data = data, h = 1, kernel = "gaussian", shape = "monotone")
for(i in 1:length(r)) v6[i] <- ksreflect(r = r[i], data = data, h = 1, kernel = "uniform", shape = "monotone")
par(mfrow = c(1, 2))
plot(r, v1, type="l", col = "red", ylim = c(-0.5, 2))
lines(r, v2, col="blue")
lines(r, v3, col="green")
plot(r, v4, type="l", col = "red", ylim = c(-0.5, 2))
lines(r, v5, col="blue")
lines(r, v6, col="green")
par(mfrow = c(1, 1))
ksreflect(0.5, c(0.5, 0.75, 1.0), 0.25, "epan", "general")
ksreflect_C(0.5, c(0.5, 0.75, 1.0), 0.25, "epan", "general")
library(NPcov)
ksreflect(0.5, c(0.5, 0.75, 1), "epan", "general")
ksreflect(0.5, c(0.5, 0.75, 1))
ksreflect(0.5, c(0.5, 0.75, 1), 0.15, "epan", "general")
ksreflect_C(0.5, c(0.5, 0.75, 1), 0.15, "epan", "general")
library(NPcov)
eval_sse_C(matrix(c(1,2,3,4), 2, 2), c(1,2), c(1,2), 0.1, "epan", "general")
library(NPcov)
library(NPcov)
NPcov::eval_sse(matrix(c(1,2,3,4),2,2), c(1,2), c(1,2), 0.12, "epan", "general")
eval_sse_C(matrix(c(1,2,3,4),2,2), c(1,2), c(1,2), 0.12, "epan", "general")
