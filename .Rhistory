y_err       <- y + rnorm(length(y), 0, 0.2)
r           <- seq(0.05, 10, by = 0.05)
ptm         <- proc.time()
storage     <- IDEA(x, y_err, h, n, m, tau, kernel, shape, method, dist_init, min_iter, max_iter)
library(NPcov)
m           <- 20
n           <- 100
tau         <- 0.2
h           <- 0.1
kernel      <- "gaussian"
shape       <- "general"
method      <- "reflection"
dist_init   <- "exponential"
min_iter    <- 20
max_iter    <- 100
wave_model  <- function(h, c_0, c_1, a) ifelse(h == 0, 0, c_0 + c_1 * (1-a*sin(h/a)/h))
x           <- seq(0.1, 10, by = 0.1)
y           <- wave_model(x, 0, 1, 1)
y           <- 1 - y
y_err       <- y + rnorm(length(y), 0, 0.2)
r           <- seq(0.05, 10, by = 0.05)
ptm         <- proc.time()
storage     <- IDEA(x, y_err, h, n, m, tau, kernel, shape, method, dist_init, min_iter, max_iter)
ptm         <- proc.time() - ptm
data        <- na.omit( unlist(storage[[2]]) )
z           <- rep(NA, length(r))
for(i in 1:length(r)) z[i] <- ksreflect(r = r[i], data = data, h = h, kernel = kernel, shape = shape)
plot(x, y_err, col = "gray")
lines(r, z, col = "red", lwd = 2)
lines(x, y, col = "black", lwd = 2)
plot(na.omit(storage$history_obj_min), type="l", ylim = c(4, 15), lty = "dotted", xlab = "Iteration", ylab = "Objective value")
lines(na.omit(storage$history_obj_max_sel), col = "red")
lines(na.omit(storage$history_obj_mean), col = "blue")
lines(na.omit(storage$history_obj_max), lty = "dotted")
ptm
history_obj_min         <- rep(NA, max_iter)
history_obj_max         <- rep(NA, max_iter)
history_obj_max_sel     <- rep(NA, max_iter)
history_obj_mean        <- rep(NA, max_iter)
history_KL              <- rep(NA, max_iter)
storage                 <- .initialization(n, m, dist_init)
storage                 <- NPcov:::.initialization(n, m, dist_init)
obj_value               <- eval_sse_C(as.matrix(storage), x, y, h, kernel, shape) # eval_sse(storage, x, y, h, kernel, shape)
install.packages("foreach")
library(NPcov)
?ksreflect
?IDEA
wave_model  <- function(h, c_0, c_1, a) ifelse(h == 0, 0, c_0 + c_1 * (1-a*sin(h/a)/h))
x = seq(0.1, 10, by = 0.1)
y = wave_model(x, 0, 1, 1)
y = 1 - y
h = 0.1
m = 20
tau = 0.2
eval = NULL
kernel = "epan"
shape = "general"
method = "reflection"
dist_init = "exponential"
min_iter = 20
max_iter = 400
tol = 1e-3
check = 5
eval <- x
### IDEA
output    <- IDEA(x = x, y = y, h = h, n = n, m = m, tau = tau, kernel = kernel, shape = shape, method = method, dist_init = dist_init, min_iter = min_iter, max_iter = max_iter, tol = tol, check = check)
n = 100
### IDEA
output    <- IDEA(x = x, y = y, h = h, n = n, m = m, tau = tau, kernel = kernel, shape = shape, method = method, dist_init = dist_init, min_iter = min_iter, max_iter = max_iter, tol = tol, check = check)
pseudo    <- as.numeric(na.omit(unlist(result$storage)))
pseudo    <- as.numeric(na.omit(unlist(output$storage)))
### ksreflect
z         <- rep(NA, length(eval))
for(i in 1:length(z)) z[i] <- ksreflect_C(eval[i], pseudo, h, kernel, shape)
plot(eval, z)
plot(eval, y)
### ksreflect
z         <- rep(NA, length(eval))
for(i in 1:length(z)) z[i] <- ksreflect_C(eval[i], pseudo, h, kernel, shape)
plot(eval, z)
plot(eval, z, type = "l")
pseudo
### ksreflect
z         <- rep(NA, length(eval))
for(i in 1:length(z)) z[i] <- ksreflect(eval[i], pseudo, h, kernel, shape)
plot(eval, z, type = "l")
plot(x, y)
output$iteration
wave_model  <- function(h, c_0, c_1, a) ifelse(h == 0, 0, c_0 + c_1 * (1-a*sin(h/a)/h))
x = seq(0.1, 10, by = 0.1)
y = wave_model(x, 0, 1, 1)
y = 1 - y
h = 0.1
n = 100
m = 20
tau = 0.2
eval = NULL
kernel = "epan"
shape = "general"
method = "reflection"
dist_init = "exponential"
min_iter = 20
max_iter = 400
tol = 1e-3
check = 5
eval <- x
### IDEA
output    <- IDEA(x = x, y = y, h = h, n = n, m = m, tau = tau, kernel = kernel, shape = shape, method = method, dist_init = dist_init, min_iter = min_iter, max_iter = max_iter, tol = tol, check = check)
pseudo    <- as.numeric(na.omit(unlist(output$storage)))
### ksreflect
z         <- rep(NA, length(eval))
for(i in 1:length(z)) z[i] <- ksreflect_C(eval[i], pseudo, h, kernel, shape)
plot(eval, z, type = "l")
kernel = "gaussian"
output    <- IDEA(x = x, y = y, h = h, n = n, m = m, tau = tau, kernel = kernel, shape = shape, method = method, dist_init = dist_init, min_iter = min_iter, max_iter = max_iter, tol = tol, check = check)
pseudo    <- as.numeric(na.omit(unlist(output$storage)))
z         <- rep(NA, length(eval))
for(i in 1:length(z)) z[i] <- ksreflect_C(eval[i], pseudo, h, kernel, shape)
plot(eval, z, type = "l")
pseudo
ksreflect_C(1, pseudo, 0.15, "epan", "general")
ksreflect_C(2, pseudo, 0.15, "epan", "general")
ksreflect_C(3, pseudo, 0.15, "epan", "general")
ksreflect(3, pseudo, 0.15, "epan", "general")
ksreflect(2, pseudo, 0.15, "epan", "general")
ksreflect(1, pseudo, 0.15, "epan", "general")
ksreflect_C(1, pseudo, 0.15, "epan", "general")
ksreflect_C(1, 1, 0.15, "epan", "general")
ksreflect(1, 1, 0.15, "epan", "general")
kernel = "uniform"
output    <- IDEA(x = x, y = y, h = h, n = n, m = m, tau = tau, kernel = kernel, shape = shape, method = method, dist_init = dist_init, min_iter = min_iter, max_iter = max_iter, tol = tol, check = check)
pseudo    <- as.numeric(na.omit(unlist(output$storage)))
z         <- rep(NA, length(eval))
for(i in 1:length(z)) z[i] <- ksreflect_C(eval[i], pseudo, h, kernel, shape)
plot(eval, z, type = "l")
est_2d_epan_refl            <- function(r, data, h){
value <- 0
for(j in 1:length(data)){
value <- value + (1-(data[j]/h)^2) * (Lambda0(r*(data[j]+h)) - Lambda0(r*(data[j]-h))) -
((r^2*(data[j]+h)^2 * besselJ_modified(r*(data[j]+h), nu = 1) - L(r*(data[j]+h)))-(r^2*(data[j]-h)^2 * besselJ_modified(r*(data[j]-h), nu = 1) - L(r*(data[j]-h)))) / (r * h)^2 +
(2 * data[j] / r / h^2) * (r*(data[j]+h)*besselJ_modified(r*(data[j]+h), nu = 1) - r*(data[j]-h)*besselJ_modified(r*(data[j]-h), nu = 1))
}
value <- value*3/4/length(data)/h/r
value
}
est_2d_epan_refl(0.1, 0.1, 0.1)
L                 <- function(x){
(pi * x / 2) * (besselJ_modified(x, nu = 1) * struveH_modified(x, nu = 0) -  besselJ_modified(x, nu = 0) * struveH_modified(x, nu = 1))
}
Lambda0           <- function(x){
x * besselJ_modified(x, nu = 0) + L(x)
}
est_2d_epan_refl(0.1, 0.1, 0.1)
besselJ_modified  <- function(x, nu){
if(x >= 0){
besselJ(x, nu)
} else {
(-1)^nu * besselJ(-x, nu)
}
}
struveH_modified  <- function(x, nu){
if(x >= 0){
struveH(x, nu)
} else {
(-1)^(nu+1) * struveH(-x, nu)
}
}
GbesselJ_modified <- function(r, h, t){
temp <- integrate(function(x) exp(0.25 * h^2 * r^2 * cos(2 * x)) * cos(r * t * sin(x)), lower = 0, upper = pi, stop.on.error = FALSE)
temp$value
}
est_2d_epan_refl(0.1, 0.1, 0.1)
require(ks)
require(RandomFieldsUtils)
require(Bessel)
est_2d_epan_refl(0.1, 0.1, 0.1)
ksreflect_C(0.1, 0.1, 0.1, "epan", "general")
ksreflect_C(0.5, 0.5, 0.15, "epan", "general")
est_2d_epan_refl(0.5, 0.5, 0.15)
ksreflect(0.5, 0.5, 0.15, "epan", "general")
NPcov:::.est_2d_epan_refl(0.5, 0.5, 0.15)
library(NPcov)
ksreflect(0.5, 0.5, 0.15)
ksreflect_C(0.5, 0.5, 0.15, "epan", "general")
est_2d_epan_refl            <- function(r, data, h){
value <- 0
for(j in 1:length(data)){
value <- value + (1-(data[j]/h)^2) * (Lambda0(r*(data[j]+h)) - Lambda0(r*(data[j]-h))) -
((r^2*(data[j]+h)^2 * besselJ_modified(r*(data[j]+h), nu = 1) - L(r*(data[j]+h)))-(r^2*(data[j]-h)^2 * besselJ_modified(r*(data[j]-h), nu = 1) - L(r*(data[j]-h)))) / (r * h)^2 +
(2 * data[j] / r / h^2) * (r*(data[j]+h)*besselJ_modified(r*(data[j]+h), nu = 1) - r*(data[j]-h)*besselJ_modified(r*(data[j]-h), nu = 1))
}
value <- value*3/4/length(data)/h/r
value
}
besselJ_modified  <- function(x, nu){
if(x >= 0){
besselJ(x, nu)
} else {
(-1)^nu * besselJ(-x, nu)
}
}
struveH_modified  <- function(x, nu){
if(x >= 0){
struveH(x, nu)
} else {
(-1)^(nu+1) * struveH(-x, nu)
}
}
L                 <- function(x){
(pi * x / 2) * (besselJ_modified(x, nu = 1) * struveH_modified(x, nu = 0) -  besselJ_modified(x, nu = 0) * struveH_modified(x, nu = 1))
}
Lambda0           <- function(x){
x * besselJ_modified(x, nu = 0) + L(x)
}
GbesselJ_modified <- function(r, h, t){
temp <- integrate(function(x) exp(0.25 * h^2 * r^2 * cos(2 * x)) * cos(r * t * sin(x)), lower = 0, upper = pi, stop.on.error = FALSE)
temp$value
}
est_2d_epan_refl(0.5, 0.5, 0.15)
require(ks)
require(RandomFieldsUtils)
require(Bessel)
est_2d_epan_refl(0.5, 0.5, 0.15)
library(NPcov)
wave_model  <- function(h, c_0, c_1, a) ifelse(h == 0, 0, c_0 + c_1 * (1-a*sin(h/a)/h))
x = seq(0.1, 10, by = 0.1)
y = wave_model(x, 0, 1, 1)
y = 1 - y
h = 0.1
n = 100
m = 20
tau = 0.2
eval = NULL
kernel = "epan"
shape = "general"
method = "reflection"
dist_init = "exponential"
min_iter = 20
max_iter = 400
tol = 1e-3
check = 5
eval <- x
output    <- IDEA(x = x, y = y, h = h, n = n, m = m, tau = tau, kernel = kernel, shape = shape, method = method, dist_init = dist_init, min_iter = min_iter, max_iter = max_iter, tol = tol, check = check)
pseudo    <- as.numeric(na.omit(unlist(output$storage)))
### ksreflect
z         <- rep(NA, length(eval))
for(i in 1:length(z)) z[i] <- ksreflect_C(eval[i], pseudo, h, kernel, shape)
plot(x, z)
hs <- c(0.1, 0.2)
ns <- c(100, 200)
ms <- c(10, 20)
taus <- c(0.1, 0.2)
expand.grid(hs, ns, ms, taus)
install.packages("doParallel")
inputs
inputs <- expand.grid(hs, ns, ms, taus)
class(inputs)
usethis::use_package("foreach")
usethis::use_package("doParallel")
wave_model  <- function(h, c_0, c_1, a) ifelse(h == 0, 0, c_0 + c_1 * (1-a*sin(h/a)/h))
x = seq(0.1, 10, by = 0.1)
y = wave_model(x, 0, 1, 1)
y = 1 - y
hs <- c(0.1, 0.2)
ns <- c(100, 200)
ms <- c(10, 20)
taus <- c(0.1, 0.2)
eval = NULL
kernel = "epan"
shape = "general"
method = "reflection"
dist_init = "exponential"
min_iter = 20
max_iter = 400
tol = 1e-3
check = 5
no_cores = NULL
eval <- x
inputs            <- expand.grid(hs, ns, ms, taus)
colnames(inputs)  <- c("h", "n", "m", "tau")
library(foreach)
usethis::use_package("parallel")
no_cores  <- parallel::detectCores() - 2
### simulation
output            <- list()
cl                <- parallel::makeCluster(no_cores)
doParallel::registerDoParallel(cl)
output            <- foreach::foreach(h = inputs$h, n = inputs$n, m = inputs$m, tau = inputs$tau, .packages = c("NPcov")) %dopar% pdnr(x = x, y = y, h = h, n = n, m = m, tau = tau, eval = eval, kernel = kernel, shape = shape, method = method, dist_init = dist_init, min_iter = min_iter, max_iter = max_iter, tol = tol, check = check)
parallel::stopCluster(cl)
length(output)
?foreach::foreach
idx               <- sample(1:10)
idx
sort(cut(idx, breaks = 3, labels = FALSE))
cut(idx, breaks = 3, labels = FALSE)
cut(sample(1:10), breaks = 3, labels = FALSE)
cut(sample(1:10), breaks = 3, labels = FALSE)
table(cut(sample(1:10), breaks = 3, labels = FALSE))
table(cut(sample(1:10), breaks = 3, labels = FALSE))
table(cut(sample(1:10), breaks = 3, labels = FALSE))
table(cut(sample(1:10), breaks = 3, labels = FALSE))
table(cut(sample(1:10), breaks = 3, labels = FALSE))
table(cut(sample(1:10), breaks = 3, labels = FALSE))
table(cut(sample(1:10), breaks = 3, labels = FALSE))
table(cut(sample(1:10), breaks = 3, labels = FALSE))
table(cut(sample(1:10), breaks = 3, labels = FALSE))
table(cut(sample(1:12), breaks = 3, labels = FALSE))
table(cut(sample(1:13), breaks = 3, labels = FALSE))
cut(sample(1:12), breaks = 3, labels = FALSE) == 1
cut(sample(1:12), breaks = 3, labels = FALSE) == 2
cut(sample(1:12), breaks = 3, labels = FALSE) == 3
cut(sample(1:12), breaks = 3, labels = FALSE) == 4
idx
idx               <- cut(sample(1:length(12)), breaks = 3, labels = FALSE)
idx
idx               <- cut(sample(1:12), breaks = 3, labels = FALSE)
idx
(1:12)[idx != 1]
wave_model  <- function(h, c_0, c_1, a) ifelse(h == 0, 0, c_0 + c_1 * (1-a*sin(h/a)/h))
x = seq(0.1, 10, by = 0.1)
y = wave_model(x, 0, 1, 1)
y = 1 - y
hs <- c(0.1, 0.2)
ns <- c(100, 200)
ms <- c(10, 20)
taus <- c(0.1, 0.2)
eval = NULL
kernel = "epan"
shape = "general"
method = "reflection"
dist_init = "exponential"
min_iter = 20
max_iter = 400
tol = 1e-3
check = 5
no_cores = NULL
### checkargs
inputs            <- expand.grid(hs, ns, ms, taus)
colnames(inputs)  <- c("h", "n", "m", "tau")
### k-fold
idx               <- cut(sample(1:length(x)), breaks = k, labels = FALSE)
k = 5
### k-fold
idx               <- cut(sample(1:length(x)), breaks = k, labels = FALSE)
### ncores
if(is.null(ncores)) {
no_cores          <- parallel::detectCores() - 2
} else {
no_cores          <- ncores
}
no_cores          <- parallel::detectCores() - 2
### parallel CV
output            <- list()
cl                <- parallel::makeCluster(no_cores)
doParallel::registerDoParallel(cl)
for(i in 1:k) {
output[[i]]       <- foreach::foreach(h = inputs$h, n = inputs$n, m = inputs$m, tau = inputs$tau, .packages = c("NPcov")) %dopar% mspe_pdnr(x_train = x[idx != i], y_train = y[idx != i], x_test = x[idx == i], y_test = y[idx == i], h = h, n = n, m = m, tau = tau, kernel = kernel, shape = shape, method = method, dist_init = dist_init, min_iter = min_iter, max_iter = max_iter, tol = tol, check = check)
cat("Note:", i,"-th step of CV is completed ",". <", date(), ">", "\n")
} ; parallel::stopCluster(cl)
mspe_pdnr <- function(x_train, y_train, x_test, y_test, h, n, m, tau, kernel = "epan", shape = "general", method = "reflection", dist_init = "exponential", min_iter = 20, max_iter = 400, tol = 1e-3, check = 5, no_cores = NULL)
{
### IDEA
output    <- IDEA(x = x_train, y = y_train, h = h, n = n, m = m, tau = tau, kernel = kernel, shape = shape, method = method, dist_init = dist_init, min_iter = min_iter, max_iter = max_iter, tol = tol, check = check)
pseudo    <- as.numeric(na.omit(unlist(output$storage)))
### ksreflect
yhat      <- rep(NA, length(x_test))
for(i in 1:length(x_test)) yhat[i] <- ksreflect_C(x_test[i], pseudo, h, kernel, shape)
return( mean((yhat - y_test)^2) )
}
parallel::stopCluster(cl)
doParallel::registerDoParallel(cl)
for(i in 1:k) {
output[[i]]       <- foreach::foreach(h = inputs$h, n = inputs$n, m = inputs$m, tau = inputs$tau, .packages = c("NPcov")) %dopar% mspe_pdnr(x_train = x[idx != i], y_train = y[idx != i], x_test = x[idx == i], y_test = y[idx == i], h = h, n = n, m = m, tau = tau, kernel = kernel, shape = shape, method = method, dist_init = dist_init, min_iter = min_iter, max_iter = max_iter, tol = tol, check = check)
cat("Note:", i,"-th step of CV is completed ",". <", date(), ">", "\n")
} ; parallel::stopCluster(cl)
parallel::stopCluster(cl)
doParallel::registerDoParallel(cl)
for(i in 1:k) {
output[[i]]       <- list()
output[[i]]       <- foreach::foreach(h = inputs$h, n = inputs$n, m = inputs$m, tau = inputs$tau, .packages = c("NPcov")) %dopar% mspe_pdnr(x_train = x[idx != i], y_train = y[idx != i], x_test = x[idx == i], y_test = y[idx == i], h = h, n = n, m = m, tau = tau, kernel = kernel, shape = shape, method = method, dist_init = dist_init, min_iter = min_iter, max_iter = max_iter, tol = tol, check = check)
cat("Note:", i,"-th step of CV is completed ",". <", date(), ">", "\n")
} ;
parallel::stopCluster(cl)
cl
doParallel::registerDoParallel(cl)
i=1
output[[i]]       <- list()
output[[i]]       <- foreach::foreach(h = inputs$h, n = inputs$n, m = inputs$m, tau = inputs$tau, .packages = c("NPcov")) %dopar% mspe_pdnr(x_train = x[idx != i], y_train = y[idx != i], x_test = x[idx == i], y_test = y[idx == i], h = h, n = n, m = m, tau = tau, kernel = kernel, shape = shape, method = method, dist_init = dist_init, min_iter = min_iter, max_iter = max_iter, tol = tol, check = check)
inputs
mspe_pdnr(x_train = x, y_train =y, x_test = x, y_test = y, h = h, n = n, m = m, tau = tau, kernel = "epan", shape = "general", method = "reflection", dist_init = "exponential", min_iter = 20, max_iter = 400, tol = 1e-3, check = 5, no_cores = NULL)
### parallel CV
output            <- list()
cl                <- parallel::makeCluster(no_cores)
doParallel::registerDoParallel(cl)
output            <- foreach::foreach(h = inputs$h, n = inputs$n, m = inputs$m, tau = inputs$tau, .packages = c("NPcov")) %dopar% {
result            <- rep(NA, k)
for(i in 1:k) {
result[i]         <- mspe_pdnr(x_train = x[idx != i], y_train = y[idx != i], x_test = x[idx == i], y_test = y[idx == i], h = h, n = n, m = m, tau = tau, kernel = kernel, shape = shape, method = method, dist_init = dist_init, min_iter = min_iter, max_iter = max_iter, tol = tol, check = check)
}
result
}
parallel::stopCluster(cl)
output[[1]]
length(output)
inputs
nrow(inputs)
### performance
perfmat           <- matrix(NA, nrow = nrow(inputs), ncol = k)
for(i in 1:length(output)) perfmat[i, ] <- output[[i]]
perfmat           <- as.data.frame(perfmat)
perfmat
paste0("K", 1:k)
colnames(perfmat) <- paste0("fold_", 1:k)
perfmat
rowMeans(perfmat)
perfmat$overall   <- rowMeans(perfmat)
perfmat
### performance
perfmat           <- matrix(NA, nrow = nrow(inputs), ncol = k)
for(i in 1:length(output)) perfmat[i, ] <- output[[i]]
perfmat           <- as.data.frame(perfmat)
colnames(perfmat) <- paste0("MSE (fold_", 1:k, ")")
perfmat$'MSE (overall)'   <- rowMeans(perfmat)
perfmat
cbind(inputs, perfmat)
class(cbind(inputs, perfmat))
### return
result            <- cbind(inputs, perfmat)
perfmat$`MSE (overall)`
perfmat$`MSE (overall)`   <- rowMeans(perfmat)
perfmat
### best model
idx.best          <- which.min(perfmat$`MSE (overall)`)
idx.best
inputs[idx.best, ]
inputs.best       <- inputs[idx.best, ]
model.best        <- pdnr(x = x, y = y, h = inputs.best$h, n = inputs.best$n, m = inputs$m, tau = inputs$tau, eval = NULL, kernel = kernel, shape = shape, method = method, dist_init = dist_init, min_iter = min_iter, max_iter = max_iter, tol = tol, check = check)
inputs.best$h
inputs.best$n
inputs$m
model.best        <- pdnr(x = x, y = y, h = inputs.best$h, n = inputs.best$n, m = inputs.best$m, tau = inputs.best$tau, eval = NULL, kernel = kernel, shape = shape, method = method, dist_init = dist_init, min_iter = min_iter, max_iter = max_iter, tol = tol, check = check)
plot(x, model.best$yhat)
library(NPcov)
x = seq(0.1, 10, by = 0.1)
y = ftn_wave(x, 0, 1, 1)
y = 1 - y
y_err = y + rnorm(length(y), 0, 0.2)
hs = c(0.1, 0.2)
ns = c(100, 200)
ms = c(10, 20)
taus = c(0.1, 0.2)
expand = TRUE
eval = NULL
k = 5
kernel = "epan"
shape = "general"
method = "reflection"
dist_init = "exponential"
min_iter = 20
max_iter = 400
tol = 1e-3
check = 5
no_cores = NULL
output <- cv_pdnr(x = x, y = y_err, hs = hs, ns = ns, ms = ms, taus = taus, expand = expand, eval = eval, k = k, kernel = kernel, shape = shape, method = method, dist_init = dist_init, min_iter = min_iter, max_iter = max_iter, tol = tol, check = check, no_cores = no_cores)
library(NPcov)
x = seq(0.1, 10, by = 0.1)
y = ftn_wave(x, 0, 1, 1)
y = 1 - y
y_err = y + rnorm(length(y), 0, 0.2)
hs = c(0.1, 0.2)
ns = c(100, 200)
ms = c(10, 20)
taus = c(0.1, 0.2)
expand = TRUE
eval = NULL
k = 5
kernel = "epan"
shape = "general"
method = "reflection"
dist_init = "exponential"
min_iter = 20
max_iter = 400
tol = 1e-3
check = 5
no_cores = NULL
ptm <- proc.time()
output <- cv_pdnr(x = x, y = y_err, hs = hs, ns = ns, ms = ms, taus = taus, expand = expand, eval = eval, k = k, kernel = kernel, shape = shape, method = method, dist_init = dist_init, min_iter = min_iter, max_iter = max_iter, tol = tol, check = check, no_cores = no_cores)
x = seq(0.1, 10, by = 0.1)
y = ftn_wave(x, 0, 1, 1)
y = 1 - y
y_err = y + rnorm(length(y), 0, 0.2)
hs = c(0.1, 0.2)
ns = c(100, 200)
ms = c(10, 20)
taus = c(0.1, 0.2)
expand = TRUE
eval = NULL
k = 5
kernel = "epan"
shape = "general"
method = "reflection"
dist_init = "exponential"
min_iter = 20
max_iter = 400
tol = 1e-3
check = 5
ncores = NULL
ptm <- proc.time()
output <- cv_pdnr(x = x, y = y_err, hs = hs, ns = ns, ms = ms, taus = taus, expand = expand, eval = eval, k = k, kernel = kernel, shape = shape, method = method, dist_init = dist_init, min_iter = min_iter, max_iter = max_iter, tol = tol, check = check, ncores = ncores)
ptm <- proc.time() - ptm
ptm
5517/60
