lines(x, dexp(x))
par(mfrow = c(1, 1))
data <- rexp(1000)
x <- seq(min(data), 5, by = 0.05)
par(mfrow = c(1, 2))
y <- krnl(x, 0.01, data, "epan", "reflection")
z <- krnl(x, 0.01, data, "epan", "transformation")
plot(x,y, type="l", ylim=c(0,2), col="blue")
lines(x,z, col="red")
lines(x, dexp(x))
y <- krnl(x, 1, data, "epan", "reflection")
z <- krnl(x, 1, data, "epan", "transformation")
plot(x,y, type="l", ylim=c(0,2), col="blue")
lines(x,z, col="red")
lines(x, dexp(x))
par(mfrow = c(1, 1))
library(NPcov)
?ksreflect
library(NPcov)
library(NPcov)
?rkrl
library(NPcov)
m           <- 20
n           <- 100
tau         <- 0.2
h = 0.1
monotone = FALSE
kernel = "gaussian"
method = "reflection"
dist_init = "exponential"
min_iter = 20
max_iter = 100
err = 1e-3
x           <- seq(0.1, 10, by = 0.1)
y           <- wave_model(x, 0,1,1)
wave_model                  <- function(h, c_0, c_1, a){
ifelse(h == 0, 0, c_0 + c_1 * (1-a*sin(h/a)/h))
}
m           <- 20
n           <- 100
tau         <- 0.2
h = 0.1
wave_model                  <- function(h, c_0, c_1, a){
ifelse(h == 0, 0, c_0 + c_1 * (1-a*sin(h/a)/h))
}
monotone = FALSE
kernel = "gaussian"
method = "reflection"
dist_init = "exponential"
min_iter = 20
max_iter = 100
err = 1e-3
x           <- seq(0.1, 10, by = 0.1)
y           <- wave_model(x, 0,1,1)
y           <- 1-y
y_err       <- y + rnorm(length(y), 0, 0.2)
r = seq(0.05, 10, by = 0.05)
ptm         <- proc.time()
storage     <- IDEA(x, y_err, h, n, m, tau, kernel, "monotone", method, dist_init, min_iter, max_iter)
ptm         <- proc.time() - ptm
data = unlist(storage[[2]]) %>% na.omit()
z = 1:length(r)
for(i in 1:length(r)) z[i] <- ksreflect(r = r[i], data = data, h = h, kernel = kernel, shape = "general")
plot(x,y_err)
lines(r,z)
lines(x,y, type="l")
plot(x,y_err)
ptm
m           <- 20
n           <- 100
tau         <- 0.2
h           <- 0.1
kernel      <- "gaussian"
method      <- "reflection"
dist_init   <- "exponential"
min_iter    <- 20
max_iter    <- 100
wave_model  <- function(h, c_0, c_1, a) ifelse(h == 0, 0, c_0 + c_1 * (1-a*sin(h/a)/h))
x           <- seq(0.1, 10, by = 0.1)
y           <- wave_model(x, 0,1,1)
y           <- 1-y
y_err       <- y + rnorm(length(y), 0, 0.2)
r           <- seq(0.05, 10, by = 0.05)
ptm         <- proc.time()
storage     <- IDEA(x, y_err, h, n, m, tau, kernel, "general", method, dist_init, min_iter, max_iter)
ptm         <- proc.time() - ptm
data        <- na.omit( unlist(storage[[2]]) %>% )
data        <- na.omit( unlist(storage[[2]]) )
z           <- rep(NA, length(r))
for(i in 1:length(r)) z[i] <- ksreflect(r = r[i], data = data, h = h, kernel = kernel, shape = shape)
shape       <- "general"
z           <- rep(NA, length(r))
for(i in 1:length(r)) z[i] <- ksreflect(r = r[i], data = data, h = h, kernel = kernel, shape = shape)
plot(x, y_err, col = "gray")
lines(r, z, col = "red", lwd = 2)
lines(x, y, col = "black", lwd = 2)
plot(na.omit(storage$history_obj_min), type="l", ylim = c(4, 15))
lines(na.omit(storage$history_obj_max_sel))
lines(na.omit(storage$history_obj_mean))
lines(na.omit(storage$history_obj_max))
ptm
plot(na.omit(storage$history_obj_min), type="l", ylim = c(4, 15), lty = "dotted")
lines(na.omit(storage$history_obj_max_sel), lty = "dotted")
lines(na.omit(storage$history_obj_max_sel), col = "red")
lines(na.omit(storage$history_obj_mean), col = "blue")
lines(na.omit(storage$history_obj_max), lty = "dotted")
plot(na.omit(storage$history_obj_min), type="l", ylim = c(4, 15), lty = "dotted", xlab = "Iteration", ylab = "Objective value")
lines(na.omit(storage$history_obj_max_sel), col = "red")
lines(na.omit(storage$history_obj_mean), col = "blue")
lines(na.omit(storage$history_obj_max), lty = "dotted")
ptm
m           <- 10
n           <- 100
tau         <- 0.2
h           <- 0.1
kernel      <- "gaussian"
shape       <- "general"
method      <- "reflection"
dist_init   <- "exponential"
min_iter    <- 20
max_iter    <- 100
wave_model  <- function(h, c_0, c_1, a) ifelse(h == 0, 0, c_0 + c_1 * (1-a*sin(h/a)/h))
x           <- seq(0.1, 10, by = 0.1)
y           <- wave_model(x, 0, 1, 1)
y           <- 1 - y
y_err       <- y + rnorm(length(y), 0, 0.2)
r           <- seq(0.05, 10, by = 0.05)
ptm         <- proc.time()
storage     <- IDEA(x, y_err, h, n, m, tau, kernel, shape, method, dist_init, min_iter, max_iter)
ptm         <- proc.time() - ptm
data        <- na.omit( unlist(storage[[2]]) )
z           <- rep(NA, length(r))
for(i in 1:length(r)) z[i] <- ksreflect(r = r[i], data = data, h = h, kernel = kernel, shape = shape)
plot(x, y_err, col = "gray")
lines(r, z, col = "red", lwd = 2)
lines(x, y, col = "black", lwd = 2)
plot(na.omit(storage$history_obj_min), type="l", ylim = c(4, 15), lty = "dotted", xlab = "Iteration", ylab = "Objective value")
lines(na.omit(storage$history_obj_max_sel), col = "red")
lines(na.omit(storage$history_obj_mean), col = "blue")
lines(na.omit(storage$history_obj_max), lty = "dotted")
ptm
storage$iteration
###########################################################################
###
###    Author : MYEONGJONG KANG
###    E-mail : kmj.stat@gmail.com
###
###    Description :
###
###    Reference : Cressie, N. (2015). Statistics for spatial data. John Wiley & Sons.
###
###########################################################################
###########################################################################
###    Some isotropic variogram models (p61)
###########################################################################
#' Linear isotropic semivariogram model
#'
#' @param h h
#' @param c c
#' @param b b
#'
#' @return Numeric value
#' @export
#'
#' @examples
ftn_linear <- function(h, c, b)
{
ifelse(h == 0, 0, c + b * h)
}
#' Spherical isotropic semivariogram model
#'
#' @param h h
#' @param c_0 c0
#' @param c_1 c1
#' @param a a
#'
#' @return Numeric value
#' @export
#'
#' @examples
ftn_spherical <- function(h, c_0, c_1, a)
{
ifelse(h == 0, 0, ifelse(h <= a, c_0 + c_1 * (1.5*(h/a) - 0.5*(h/a)^3), c_0 + c_1))
}
#' Exponential isotropic semivariogram model
#'
#' @param h h
#' @param c_0 c0
#' @param c_1 c1
#' @param a a
#'
#' @return Numeric value
#' @export
#'
#' @examples
ftn_exponential <- function(h, c_0, c_1, a)
{
ifelse(h == 0, 0, c_0 + c_1 * (1-exp(-h/a)))
}
#' Rational quadratic semivariogram model
#'
#' @param h h
#' @param c_0 c0
#' @param c_1 c1
#' @param a a
#'
#' @return Numeric value
#' @export
#'
#' @examples
ftn_rational_quadratic <- function(h, c_0, c_1, a)
{
ifelse(h == 0, 0, c_0 + c_1 * h^2 / (1 + (h^2)/a))
}
#' Wave isotropic semivariogram model
#'
#' @param h h
#' @param c_0 c0
#' @param c_1 c1
#' @param a a
#'
#' @return Numeric value
#' @export
#'
#' @examples
ftn_wave <- function(h, c_0, c_1, a)
{
ifelse(h == 0, 0, c_0 + c_1 * (1-a*sin(h/a)/h))
}
#' Power isotropic semivariogram model
#'
#' @param h h
#' @param c c
#' @param b b
#' @param lambda lambda
#'
#' @return Numeric value
#' @export
#'
#' @examples
ftn_power <- function(h, c, b, lambda)
{
ifelse(h == 0, 0, c + b * h^lambda)
}
x = seq(0, 15, by = 0.001)
y = ftn_linear(x, 0, 1)
plot(x, y, type="l")
y = ftn_spherical(x, 0, 1, 1)
plot(x, y, type="l")
y = ftn_exponential(x, 0, 1, 1)
plot(x, y, type="l")
y = ftn_rational_quadratic(x, 0, 1, 1)
plot(x, y, type="l")
y = ftn_wave(x, 0, 1, 1)
plot(x, y, type="l")
y = ftn_power(x, 0, 1, 1)
plot(x, y, type="l")
library(NPcov)
ls("package:NPcov")
library(NPcov)
library(NPcov)
library(NPcov)
library(NPcov)
library(NPcov)
library(NPcov)
?idea
library(NPcov)
?IDEA
m           <- 20
n           <- 100
tau         <- 0.2
h           <- 0.1
kernel      <- "gaussian"
shape       <- "general"
method      <- "reflection"
dist_init   <- "exponential"
min_iter    <- 20
max_iter    <- 100
wave_model  <- function(h, c_0, c_1, a) ifelse(h == 0, 0, c_0 + c_1 * (1-a*sin(h/a)/h))
x           <- seq(0.1, 10, by = 0.1)
y           <- wave_model(x, 0, 1, 1)
y           <- 1 - y
y_err       <- y + rnorm(length(y), 0, 0.2)
r           <- seq(0.05, 10, by = 0.05)
ptm         <- proc.time()
storage     <- IDEA(x, y_err, h, n, m, tau, kernel, shape, method, dist_init, min_iter, max_iter)
ptm         <- proc.time() - ptm
data        <- na.omit( unlist(storage[[2]]) )
z           <- rep(NA, length(r))
for(i in 1:length(r)) z[i] <- ksreflect(r = r[i], data = data, h = h, kernel = kernel, shape = shape)
plot(x, y_err, col = "gray")
lines(r, z, col = "red", lwd = 2)
lines(x, y, col = "black", lwd = 2)
plot(na.omit(storage$history_obj_min), type="l", ylim = c(4, 15), lty = "dotted", xlab = "Iteration", ylab = "Objective value")
lines(na.omit(storage$history_obj_max_sel), col = "red")
lines(na.omit(storage$history_obj_mean), col = "blue")
lines(na.omit(storage$history_obj_max), lty = "dotted")
ptm
storage$iteration
history_obj_min         <- rep(NA, max_iter)
history_obj_max         <- rep(NA, max_iter)
history_obj_max_sel     <- rep(NA, max_iter)
history_obj_mean        <- rep(NA, max_iter)
history_KL              <- rep(NA, max_iter)
storage                 <- .initialization(n, m, dist_init)
.initialization <- function(n, m, dist_init = "exponential")
{
if(dist_init == "exponential"){
storage     <- as.data.frame(matrix(rexp(n * m), m, n))
} else {
storage     <- as.data.frame(matrix(rexp(n * m), m, n))
} ; colnames(storage) <- paste0("Z", 1:n)
return( storage )
}
.selection <- function(storage, tau, objective)
{
storage     <- storage[,order(objective)]
objective   <- objective[order(objective)]
storage[,(as.integer(tau * ncol(storage)) + 1):ncol(storage)] <- NA
return( storage )
}
.replacement <- function(storage, tau, h, kernel = "epan", method = "reflection")
{
n           <- ncol(storage)
m           <- nrow(storage)
num_sample  <- as.integer(tau * n)
data        <- as.numeric(na.omit(unlist(storage)))
storage           <- cbind(storage[,1:num_sample], matrix(rkrnl((n - num_sample) * m, data, h, kernel, method), m, n-num_sample))
colnames(storage) <- paste0("Z", 1:n)
return( storage )
}
.termination <- function(storage_old, storage, h, kernel = "epan", method = "reflection") {
data_old <- na.omit(unlist(storage_old))
data_new <- na.omit(unlist(storage))
abs(sum( log( krnl(data_old, h, data_old, kernel, method) / krnl(data_new, h, data_old, kernel, method) ) )) / length(data_old)
}
history_obj_min         <- rep(NA, max_iter)
history_obj_max         <- rep(NA, max_iter)
history_obj_max_sel     <- rep(NA, max_iter)
history_obj_mean        <- rep(NA, max_iter)
history_KL              <- rep(NA, max_iter)
storage                 <- .initialization(n, m, dist_init)
obj_value               <- eval_sse(storage, x, y, h, kernel, shape)
history_obj_min[1]      <- min(obj_value)
history_obj_mean[1]     <- mean(obj_value)
history_obj_max[1]      <- max(obj_value)
storage                 <- .selection(storage, tau, obj_value)
history_obj_max_sel[1]  <- obj_value[order(obj_value)][(as.integer(tau * ncol(storage)))]
library(NPcov)
library(NPcov)
library(NPcov)
library(NPcov)
library(NPcov)
library(NPcov)
library(NPcov)
library(NPcov)
library(NPcov)
library(NPcov)
library(NPcov)
library(NPcov)
library(NPcov)
RandomFieldsUtils::struveH(0.5, 0.5)
NPcov:::StruveH(0.5, 0.5)
RandomFieldsUtils::struveH
library(NPcov)
C_StruveH
.struve <- function(x, nu) {
storage.mode(x) <- "double"
storage.mode(nu) <- "double"
.Call(C_StruveH, x, nu)
}
struveH <- function(x, nu)  .struve(x, nu)
struveH(0.5, 0.5)
.struve <- function(x, nu) {
storage.mode(x) <- "double"
storage.mode(nu) <- "double"
.Call(StruveH, x, nu)
}
struveH <- function(x, nu)  .struve(x, nu)
struveH(0.5, 0.5)
.struve <- function(x, nu) {
storage.mode(x) <- "double"
storage.mode(nu) <- "double"
.Call(NPcov:::StruveH, x, nu)
}
struveH <- function(x, nu)  .struve(x, nu)
struveH(0.5, 0.5)
library(NPcov)
.struve <- function(x, nu) {
storage.mode(x) <- "double"
storage.mode(nu) <- "double"
.Call(NPcov:::StruveH, x, nu)
}
struveH <- function(x, nu)  .struve(x, nu)
struveH(0.5, 0.5)
.struve <- function(x, nu) {
storage.mode(x) <- "double"
storage.mode(nu) <- "double"
NPcov:::StruveH(x, nu)
}
struveH <- function(x, nu)  .struve(x, nu)
struveH(0.5, 0.5)
struveH
library(NPcov)
.struve <- function(x, nu) {
storage.mode(x) <- "double"
storage.mode(nu) <- "double"
NPcov:::StruveH(x, nu)
}
struveHa <- function(x, nu)  .struve(x, nu)
struveHa(0.5, 0.5)
struveHa(0.5, 0.5)
x=0.5
nu = 0.5
storage.mode(x) <- "double"
storage.mode(nu) <- "double"
NPcov:::StruveH(x, nu)
NPcov:::StruveH(x, nu)
library(NPcov)
library(NPcov)
library(NPcov)
library(NPcov)
library(NPcov)
library(NPcov)
NPcov:::StruveH(0.5, 0.5)
NPcov::StruveH(0.5, 0.5)
StruveH(0.5, 0.5)
library(NPcov)
library(NPcov)
struve(0.5, 0.5)
NPcov:::struve(0.5, 0.5)
struve
NPcov:::struve
library(NPcov)
NPcov:::struve(0.5, 0.5)
library(NPcov)
NPcov:::struve(0.5, 0.5)
NPcov:::StruveH()
NPcov:::StruveH(0.5, 0.5)
NPcov:::StruveH(as.double(0.5), as.double(0.5))
temp <- NPcov:::StruveH(0.5, 0.5)
library(NPcov)
temp <- NPcov:::StruveH(0.5, 0.5)
temp <- NPcov:::struve(0.5, 0.5)
library(NPcov)
library(NPcov)
temp <- NPcov:::struve(0.5, 0.5)
NPcov:::StruveH(0.5, 0.5)
library(NPcov)
struve(0.5, 0.5)
RandomFieldsUtils::struveH(0.5, 0.5)
x = 0.2 ; nu = 0.3 ; struve(x, nu) ; RandomFieldsUtils::struveH(x, nu)
x = 0.2 ; nu = 0.1 ; struve(x, nu) ; RandomFieldsUtils::struveH(x, nu)
x = 0.8 ; nu = 0.1 ; struve(x, nu) ; RandomFieldsUtils::struveH(x, nu)
library(NPcov)
library(NPcov)
besselK
besselJ(0.5, 0.5)
stat::besselJ(0.5, 0.5)
stat:::besselJ(0.5, 0.5)
besselJ(0.5, 0.5)
0.5409738
library(NPcov)
library(NPcov)
install.packages("RcppNumerical")
install.packages("RcppEigen")
usethis::use_package("RcppNumerical")
?usethis::use_package
usethis::use_package("RcppEigen", "LinkingTo")
usethis::use_package("RcppNumerical", "LinkingTo")
library(NPcov)
NPcov:::integrate_test()
library(NPcov)
integrate_test()
library(NPcov)
integrate_test(0.5, 0.5, 0.5)
library(NPcov)
integrate_test(0.5, 0.5, 0.5)
library(NPcov)
NPcov:::.besselJ_generalized(0.5, 0.5, 0.5)
integrate_test(0.5, 0.5, 0.5)
library(NPcov)
NPcov:::.besselJ_generalized(0.5, 0.5, 0.5)
besselJ_generalized_C(0.5, 0.5, 0.5)
NPcov:::.besselJ_generalized(0.5, 0.5, 0.76)
besselJ_generalized_C(0.5, 0.5, 0.76)
library(NPcov)
NPcov:::.struveH_modified(0.5, 0.5)
NPcov:::.struveH_modified(-0.5, 0.5)
RandomFieldsUtils::struveH(-0.5, 0.5)
struveH_modified_C(0.5, 0.5)
struveH_modified_C(-0.5, 0.5)
besselJ_modified_C(0.5, 0.5)
besselJ_modified_C(-0.5, 0.5)
NPcov:::.besselJ_modified(0.5, 0.5)
NPcov:::.besselJ_modified(-0.5, 0.5)
NPcov:::.besselJ_generalized(0.5, 0.5, 0.5)
besselJ_generalized_C(0.5, 0.5, 0.5)
library(NPcov)
besselJ_modified_C(0.5, 0.5)
besselJ_generalized_C(0.5, 0.5, 0.5)
struveH_modified_C(0.5, 0.5)
NPcov:::.struveH_modified(0.5, 0.5)
library(NPcov)
library(NPcov)
lmda0_C(0.5)
NPcov:::.lmda0(0.5)
library(NPcov)
lmda1_C(0.5)
NPcov:::.lmda1(0.5)
NPcov:::.lmda1(0.7)
lmda1_C(0.7)
